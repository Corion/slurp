<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <link rel="stylesheet" href="/s/style.css" type="text/css">
  <title>search.cpan.org: File::Slurp - Efficient Reading/Writing of Complete Files</title>
 </head>
 <body  id=cpansearch class=std>

<table width="100%"><tr><td rowspan=2 width="5%">
<a href="/"><img src="/s/img/cpan_banner.png" alt="The CPAN Search Site"></a>
</td>
<td>
<div class=menubar>&nbsp;
 <a class=m href="/">Home</a> &nbsp;&nbsp;
 <a class=m href="/author/">Authors</a> &nbsp;&nbsp;
 <a class=m href="/recent">Recent</a> &nbsp;&nbsp;
 <a class=m href="/site.html">About</a> &nbsp;&nbsp;
 <a class=m href="/mirror">Mirrors</a> &nbsp;&nbsp;
 <a class=m href="/faq.html">FAQ</a> &nbsp;&nbsp;
 <a class=m href="/feedback">Feedback</a>
&nbsp;</div>

</td></tr><tr><td>
 
<form method=get action="/search" name=f><table><tr><td>
<input type="text" name="query" value="" size=35 ></td></tr><tr><td>in <select name="mode">
 <option value="all">All</option>
 <option value="module" >Modules</option>
 <option value="dist" >Distributions</option>
 <option value="author" >Authors</option>
</select>&nbsp;<input type="submit" value="CPAN Search">
</td></tr></table>
</form>

</td></tr></table>

  

 <a name="_top"></a>
 
 <div class=path>
  <a href="/~uri/">Uri Guttman</a> >
  <a href="/~uri/File-Slurp-9999.01/">File-Slurp-9999.01</a> >
  File::Slurp
 </div>

  Module Version:  9999.01 &nbsp;
  <a href="/src/URI/File-Slurp-9999.01/lib/File/Slurp.pm">Source</a> &nbsp;
 <p /><div class=pod>
<a name="_top"></a>
<div class=pod>
<div class=toc><ul><li><a href="#NAME">NAME</a>
<li><a href="#SYNOPSIS">SYNOPSIS</a>
<li><a href="#DESCRIPTION">DESCRIPTION</a>
<ul><li><a href="#read_file">read_file</a>
<ul><li><a href="#binmode">binmode</a>
<li><a href="#array_ref">array_ref</a>
<li><a href="#scalar_ref">scalar_ref</a>
<li><a href="#buf_ref">buf_ref</a>
<li><a href="#blk_size">blk_size</a>
<li><a href="#err_mode">err_mode</a>
</ul>
<li><a href="#write_file">write_file</a>
<ul><li><a href="#binmode">binmode</a>
<li><a href="#buf_ref">buf_ref</a>
<li><a href="#append">append</a>
<li><a href="#err_mode">err_mode</a>
</ul>
<li><a href="#overwrite_file">overwrite_file</a>
<li><a href="#append_file">append_file</a>
<li><a href="#read_dir">read_dir</a>
<li><a href="#EXPORT">EXPORT</a>
</ul>
<li><a href="#AUTHOR">AUTHOR</a>
</ul>
</div>
<!-- generated by TUCS::Pod2HTML v, using Pod::Simple::PullParser v2.02, under Perl v5.006001 at Tue Dec  9 05:21:57 2003 GMT -->
<!-- start doc -->

<h1><a name="NAME"></a
>NAME <a href='#_top'><img alt='^' src='/s/img/up.gif'></a></h1>

<p>File::Slurp &#45; Efficient Reading/Writing of Complete Files</p>

<h1><a name="SYNOPSIS"></a
>SYNOPSIS <a href='#_top'><img alt='^' src='/s/img/up.gif'></a></h1>

<pre>  use File::Slurp;

  my $text = read_file( &#39;filename&#39; ) ;
  my @lines = read_file( &#39;filename&#39; ) ;

  write_file( &#39;filename&#39;, @lines ) ;</pre>

<h1><a name="DESCRIPTION"></a
>DESCRIPTION <a href='#_top'><img alt='^' src='/s/img/up.gif'></a></h1>

<p>This module provides subs that allow you to read or write entire files with one simple call. They are designed to be simple to use, have flexible ways to pass in or get the file contents and to be very efficient. There is also a sub to read in all the files in a directory other than <code>.</code> and <code>..</code></p>

<p>Note that these slurp/spew subs work only for files and not for pipes or stdio. If you want to slurp the latter, use the standard techniques such as setting $/ to undef, reading &#60;&#62; in a list context, or printing all you want to STDOUT.</p>

<h2><a name="read_file"></a
><b>read_file</b></h2>

<p>This sub reads in an entire file and returns its contents to the caller. In list context it will return a list of lines (using the current value of $/ as the separator. In scalar context it returns the entire file as a single scalar.</p>

<pre>  my $text = read_file( &#39;filename&#39; ) ;
  my @lines = read_file( &#39;filename&#39; ) ;</pre>

<p>The first argument to <code>read_file</code> is the filename and the rest of the arguments are key/value pairs which are optional and which modify the behavior of the call. Other than binmode the options all control how the slurped file is returned to the caller.</p>

<p>If the first argument is a file handle reference or I/O object (if fileno returns a defined value), then that handle is slurped in. This mode is supported so you slurp handles such as &#60;DATA&#62;, \*STDIN. See the test handle.t for an example that does <code>open( &#39;&#45;|&#39; )</code> and child process spews data to the parant which slurps it in. All of the options that control how the data is returned to the caller still work in this case.</p>

<p>The options are:</p>

<h3><a name="binmode"></a
>binmode</h3>

<p>If you set the binmode option, then the file will be slurped in binary mode.</p>

<pre>        my $bin_data = read_file( $bin_file, binmode =&#62; &#39;:raw&#39; ) ;</pre>

<p>NOTE: this actually sets the O_BINARY mode flag for sysopen. It probably should call binmode and pass its argument to support other file modes.</p>

<h3><a name="array_ref"></a
>array_ref</h3>

<p>If this boolean option is set, the return value (only in scalar context) will be an array reference which contains the lines of the slurped file. The following two calls are equivilent:</p>

<pre>        my $lines_ref = read_file( $bin_file, array_ref =&#62; 1 ) ;
        my $lines_ref = [ read_file( $bin_file ) ] ;</pre>

<h3><a name="scalar_ref"></a
>scalar_ref</h3>

<p>If this boolean option is set, the return value (only in scalar context) will be an scalar reference to a string which is the contents of the slurped file. This will usually be faster than returning the plain scalar.</p>

<pre>        my $text_ref = read_file( $bin_file, scalar_ref =&#62; 1 ) ;</pre>

<h3><a name="buf_ref"></a
>buf_ref</h3>

<p>You can use this option to pass in a scalar reference and the slurped file contents will be stored in the scalar. This can be used in conjunction with any of the other options.</p>

<pre>        my $text_ref = read_file( $bin_file, buf_ref =&#62; \$buffer,
                                             array_ref =&#62; 1 ) ;
        my @lines = read_file( $bin_file, buf_ref =&#62; \$buffer ) ;</pre>

<h3><a name="blk_size"></a
>blk_size</h3>

<p>You can use this option to set the block size used when slurping from an already open handle (like \*STDIN). It defaults to 1MB.</p>

<pre>        my $text_ref = read_file( $bin_file, blk_size =&#62; 10_000_000,
                                             array_ref =&#62; 1 ) ;</pre>

<h3><a name="err_mode"></a
>err_mode</h3>

<p>You can use this option to control how read_file behaves when an error occurs. This option defaults to &#39;croak&#39;. You can set it to &#39;carp&#39; or to &#39;quiet to have no error handling. This code wants to carp and then read abother file if it fails.</p>

<pre>        my $text_ref = read_file( $file, err_mode =&#62; &#39;carp&#39; ) ;
        unless ( $text_ref ) {

                # read a different file but croak if not found
                $text_ref = read_file( $another_file ) ;
        }
        
        # process ${$text_ref}</pre>

<h2><a name="write_file"></a
><b>write_file</b></h2>

<p>This sub writes out an entire file in one call.</p>

<pre>  write_file( &#39;filename&#39;, @data ) ;</pre>

<p>The first argument to <code>write_file</code> is the filename. The next argument is an optional hash reference and it contains key/values that can modify the behavior of <code>write_file</code>. The rest of the argument list is the data to be written to the file.</p>

<pre>  write_file( &#39;filename&#39;, {append =&#62; 1 }, @data ) ;
  write_file( &#39;filename&#39;, {binmode =&#62; &#39;:raw&#39; }, $buffer ) ;</pre>

<p>As a shortcut if the first data argument is a scalar or array reference, it is used as the only data to be written to the file. Any following arguments in @_ are ignored. This is a faster way to pass in the output to be written to the file and is equivilent to the <code>buf_ref</code> option. These following pairs are equivilent but the pass by reference call will be faster in most cases (especially with larger files).</p>

<pre>  write_file( &#39;filename&#39;, \$buffer ) ;
  write_file( &#39;filename&#39;, $buffer ) ;

  write_file( &#39;filename&#39;, \@lines ) ;
  write_file( &#39;filename&#39;, @lines ) ;</pre>

<p>If the first argument is a file handle reference or I/O object (if fileno returns a defined value), then that handle is slurped in. This mode is supported so you spew to handles such as \*STDOUT. See the test handle.t for an example that does <code>open( &#39;&#45;|&#39; )</code> and child process spews data to the parant which slurps it in. All of the options that control how the data is passes into <code>write_file</code> still work in this case.</p>

<p>The options are:</p>

<h3><a name="binmode"></a
>binmode</h3>

<p>If you set the binmode option, then the file will be written in binary mode.</p>

<pre>        write_file( $bin_file, {binmode =&#62; &#39;:raw&#39;}, @data ) ;</pre>

<p>NOTE: this actually sets the O_BINARY mode flag for sysopen. It probably should call binmode and pass its argument to support other file modes.</p>

<h3><a name="buf_ref"></a
>buf_ref</h3>

<p>You can use this option to pass in a scalar reference which has the data to be written. If this is set then any data arguments (including the scalar reference shortcut) in @_ will be ignored. These are equivilent:</p>

<pre>        write_file( $bin_file, { buf_ref =&#62; \$buffer } ) ;
        write_file( $bin_file, \$buffer ) ;
        write_file( $bin_file, $buffer ) ;</pre>

<h3><a name="append"></a
>append</h3>

<p>If you set this boolean option, the data will be written at the end of the current file.</p>

<pre>        write_file( $file, {append =&#62; 1}, @data ) ;</pre>

<p><code>write_file</code> croaks if it cannot open the file. It returns true if it succeeded in writing out the file and undef if there was an error. (Yes, I know if it croaks it can&#39;t return anything but that is for when I add the options to select the error handling mode).</p>

<h3><a name="err_mode"></a
>err_mode</h3>

<p>You can use this option to control how <code>write_file</code> behaves when an error occurs. This option defaults to &#39;croak&#39;. You can set it to &#39;carp&#39; or to &#39;quiet to have no error handling. If the first call to <code>write_file</code> fails it will carp and then write to another file. If the second call to <code>write_file</code> fails, it will croak.</p>

<pre>        unless ( write_file( $file, { err_mode =&#62; &#39;carp&#39;, \$data ) ;

                # write a different file but croak if not found
                write_file( $other_file, \$data ) ;
        }</pre>

<h2><a name="overwrite_file"></a
>overwrite_file</h2>

<p>This sub is just a typeglob alias to write_file since write_file always overwrites an existing file. This sub is supported for backwards compatibility with the original version of this module. See write_file for its API and behavior.</p>

<h2><a name="append_file"></a
>append_file</h2>

<p>This sub will write its data to the end of the file. It is a wrapper around write_file and it has the same API so see that for the full documentation. These calls are equivilent:</p>

<pre>        append_file( $file, @data ) ;
        write_file( $file, {append =&#62; 1}, @data ) ;</pre>

<h2><a name="read_dir"></a
>read_dir</h2>

<p>This sub reads all the file names from directory and returns them to the caller but <code>.</code> and <code>..</code> are removed.</p>

<pre>        my @files = read_dir( &#39;/path/to/dir&#39; ) ;</pre>

<p>It croaks if it cannot open the directory.</p>

<h2><a name="EXPORT"></a
>EXPORT</h2>

<pre>  read_file write_file overwrite_file append_file read_dir</pre>

<h1><a name="AUTHOR"></a
>AUTHOR <a href='#_top'><img alt='^' src='/s/img/up.gif'></a></h1>

<p>Uri Guttman, &#60;uri@stemsystems.com&#62;</p>
<!-- end doc -->

</div>


</div>

<!-- Tue Dec  9 05:21:57 2003 GMT (0.239951014518738) -->
 </body>
</html>



